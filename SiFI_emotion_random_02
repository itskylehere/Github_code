/******************************* 
 * Sifi_Emotion_Random_02 Test *
 *******************************/

import { core, data, sound, util, visual, hardware } from './lib/psychojs-2022.2.4.js';
const { PsychoJS } = core;
const { TrialHandler, MultiStairHandler } = data;
const { Scheduler } = util;
//some handy aliases as in the psychopy scripts;
const { abs, sin, cos, PI: pi, sqrt } = Math;
const { round } = util;


// store info about the experiment session:
let expName = 'SiFI_emotion_random_02';  // from the Builder filename that created this script
let expInfo = {
    'Participant ID': '',
    'Age': '',
    'Self-reported vision': ["1 - Excellent", "2 - very good", "3 - good", "4 - Fair", "5 - Poor"],
    'Self-reported hearing': ["1 - Excellent", "2 - very good", "3 - good", "4 - Fair", "5 - Poor"],
};

// Start code blocks for 'Before Experiment'
// init psychoJS:
const psychoJS = new PsychoJS({
  debug: true
});

// open window:
psychoJS.openWindow({
  fullscr: true,
  color: new util.Color([-1,-1,-1]),
  units: 'height',
  waitBlanking: true
});
// schedule the experiment:
psychoJS.schedule(psychoJS.gui.DlgFromDict({
  dictionary: expInfo,
  title: expName
}));

const flowScheduler = new Scheduler(psychoJS);
const dialogCancelScheduler = new Scheduler(psychoJS);
psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); }, flowScheduler, dialogCancelScheduler);

// flowScheduler gets run if the participants presses OK
flowScheduler.add(updateInfo); // add timeStamp
flowScheduler.add(experimentInit);
const trials_2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trials_2LoopBegin(trials_2LoopScheduler));
flowScheduler.add(trials_2LoopScheduler);
flowScheduler.add(trials_2LoopEnd);
flowScheduler.add(shuffle_stimRoutineBegin());
flowScheduler.add(shuffle_stimRoutineEachFrame());
flowScheduler.add(shuffle_stimRoutineEnd());
flowScheduler.add(hiTextRoutineBegin());
flowScheduler.add(hiTextRoutineEachFrame());
flowScheduler.add(hiTextRoutineEnd());
flowScheduler.add(beepFlashInstrucRoutineBegin());
flowScheduler.add(beepFlashInstrucRoutineEachFrame());
flowScheduler.add(beepFlashInstrucRoutineEnd());
flowScheduler.add(fixation_5RoutineBegin());
flowScheduler.add(fixation_5RoutineEachFrame());
flowScheduler.add(fixation_5RoutineEnd());
const beepFlash_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(beepFlash_loopLoopBegin(beepFlash_loopLoopScheduler));
flowScheduler.add(beepFlash_loopLoopScheduler);
flowScheduler.add(beepFlash_loopLoopEnd);
flowScheduler.add(break4RoutineBegin());
flowScheduler.add(break4RoutineEachFrame());
flowScheduler.add(break4RoutineEnd());
flowScheduler.add(practiceInstrucRoutineBegin());
flowScheduler.add(practiceInstrucRoutineEachFrame());
flowScheduler.add(practiceInstrucRoutineEnd());
const prac_sifiLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(prac_sifiLoopBegin(prac_sifiLoopScheduler));
flowScheduler.add(prac_sifiLoopScheduler);
flowScheduler.add(prac_sifiLoopEnd);
flowScheduler.add(practiceBreakRoutineBegin());
flowScheduler.add(practiceBreakRoutineEachFrame());
flowScheduler.add(practiceBreakRoutineEnd());
flowScheduler.add(SIFI_instrucRoutineBegin());
flowScheduler.add(SIFI_instrucRoutineEachFrame());
flowScheduler.add(SIFI_instrucRoutineEnd());
const baseline_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(baseline_loopLoopBegin(baseline_loopLoopScheduler));
flowScheduler.add(baseline_loopLoopScheduler);
flowScheduler.add(baseline_loopLoopEnd);
flowScheduler.add(break_2RoutineBegin());
flowScheduler.add(break_2RoutineEachFrame());
flowScheduler.add(break_2RoutineEnd());
flowScheduler.add(emotionInstrucRoutineBegin());
flowScheduler.add(emotionInstrucRoutineEachFrame());
flowScheduler.add(emotionInstrucRoutineEnd());
const trials_5LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trials_5LoopBegin(trials_5LoopScheduler));
flowScheduler.add(trials_5LoopScheduler);
flowScheduler.add(trials_5LoopEnd);
flowScheduler.add(break_2RoutineBegin());
flowScheduler.add(break_2RoutineEachFrame());
flowScheduler.add(break_2RoutineEnd());
flowScheduler.add(instrucRateRoutineBegin());
flowScheduler.add(instrucRateRoutineEachFrame());
flowScheduler.add(instrucRateRoutineEnd());
const rating_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(rating_loopLoopBegin(rating_loopLoopScheduler));
flowScheduler.add(rating_loopLoopScheduler);
flowScheduler.add(rating_loopLoopEnd);
const trialsLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trialsLoopBegin(trialsLoopScheduler));
flowScheduler.add(trialsLoopScheduler);
flowScheduler.add(trialsLoopEnd);
flowScheduler.add(endTextRoutineBegin());
flowScheduler.add(endTextRoutineEachFrame());
flowScheduler.add(endTextRoutineEnd());
flowScheduler.add(quitPsychoJS, '', true);

// quit if user presses Cancel in dialog box:
dialogCancelScheduler.add(quitPsychoJS, '', false);

psychoJS.start({
  expName: expName,
  expInfo: expInfo,
  resources: [
    {'name': 'demographics.csv', 'path': 'demographics.csv'},
    {'name': 'scale/valenceScale.png', 'path': 'scale/valenceScale.png'},
    {'name': 'scale/valenceScale.jpg', 'path': 'scale/valenceScale.jpg'},
    {'name': 'sifi_cond.xlsx', 'path': 'sifi_cond.xlsx'},
    {'name': 'beep_flash_only.xlsx', 'path': 'beep_flash_only.xlsx'},
    {'name': 'sifi_cond2.xlsx', 'path': 'sifi_cond2.xlsx'},
    {'name': 'practice_sifi.xlsx', 'path': 'practice_sifi.xlsx'},
    {'name': 'sifi_sound/150_SOA.wav', 'path': 'sifi_sound/150_SOA.wav'},
    {'name': 'sifi_sound/SOA_190.mp3', 'path': 'sifi_sound/SOA_190.mp3'},
    {'name': 'sifi_sound/200_SOA.wav', 'path': 'sifi_sound/200_SOA.wav'},
    {'name': 'scale/Next.png', 'path': 'scale/Next.png'},
    {'name': 'scale/arousalScale.jpg', 'path': 'scale/arousalScale.jpg'},
    {'name': '1_beep.wav', 'path': '1_beep.wav'},
    {'name': 'sifi_sound/50_SOA.wav', 'path': 'sifi_sound/50_SOA.wav'},
    {'name': 'sifi_sound/SOA_150.mp3', 'path': 'sifi_sound/SOA_150.mp3'},
    {'name': 'beep1.mp3', 'path': 'beep1.mp3'},
    {'name': 'sifi_sound/SOA_70.mp3', 'path': 'sifi_sound/SOA_70.mp3'},
    {'name': 'imageFiles.xlsx', 'path': 'imageFiles.xlsx'},
    {'name': 'scale/arousalScale.png', 'path': 'scale/arousalScale.png'},
    {'name': 'sifi_sound/silence.wav', 'path': 'sifi_sound/silence.wav'},
    {'name': 'rating_emotion.xlsx', 'path': 'rating_emotion.xlsx'}
  ]
});

psychoJS.experimentLogger.setLevel(core.Logger.ServerLevel.EXP);

async function updateInfo() {
  currentLoop = psychoJS.experiment;  // right now there are no loops
  expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
  expInfo['expName'] = expName;
  expInfo['psychopyVersion'] = '2022.2.4';
  expInfo['OS'] = window.navigator.platform;

  psychoJS.experiment.dataFileName = (("." + "/") + `data/${expInfo["Participant ID"]}_${expName}_${expInfo["date"]}`);

  // store frame rate of monitor if we can measure it successfully
  expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
  if (typeof expInfo['frameRate'] !== 'undefined')
    frameDur = 1.0 / Math.round(expInfo['frameRate']);
  else
    frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess

  // add info from the URL:
  util.addInfoFromUrl(expInfo);
  
  return Scheduler.Event.NEXT;
}

async function experimentInit() {
  // Initialize components for Routine "code_2"
  code_2Clock = new util.Clock();
  // Run 'Begin Experiment' code from counterbalance
  all_images = [];
  
  // Run 'Begin Experiment' code from stimLoad
  all_images = [];
  image_list_All = [];
  
  // Run 'Begin Experiment' code from selectImage
  /*pos_images = function () {
      var _pj_a = [], _pj_b = util.range(6);
      for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
          var i = _pj_b[_pj_c];
          _pj_a.push((("images/" + i.toString()) + "_pos.jpg"));
      }
      return _pj_a;
  }
  .call(this);
  neg_images = function () {
      var _pj_a = [], _pj_b = util.range(6);
      for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
          var i = _pj_b[_pj_c];
          _pj_a.push((("images/" + i.toString()) + "_neg.jpg"));
      }
      return _pj_a;
  }
  .call(this);
  neut_images = function () {
      var _pj_a = [], _pj_b = util.range(6);
      for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {
          var i = _pj_b[_pj_c];
          _pj_a.push((("images/" + i.toString()) + "_neut.jpg"));
      }
      return _pj_a;
  }
  .call(this);
  image_list_Pos = [];
  image_list_Neg = [];
  image_list_Neut = [];
  util.shuffle(pos_images);
  util.shuffle(neg_images);
  util.shuffle(neut_images);
  PositiveCond = pos_images.slice(0, 6);
  NegativeCond = neg_images.slice(0, 6);
  NeutralCond = neut_images.slice(0, 6);*/
  
  new_ISI = .5;
  // Run 'Begin Experiment' code from background
  background = new visual.Rect({
      win: psychoJS.window, width: [2,2][0], height: [2,2][1],
      lineWidth: 1.0, lineColor: new util.Color('black'),
      fillColor: new util.Color('black'), opacity: undefined,
      interpolate: true,
      });
  background.setAutoDraw(true);
  
  // Initialize components for Routine "shuffle_stim"
  shuffle_stimClock = new util.Clock();
  // Run 'Begin Experiment' code from code
  util.shuffle(all_images);
  AllCond = all_images.slice(0, 14);
  
  // Initialize components for Routine "hiText"
  hiTextClock = new util.Clock();
  helloText = new visual.TextStim({
    win: psychoJS.window,
    name: 'helloText',
    text: "Thank you for participating in this experiment.\n\nThis is the Sound-induced Flash Illusion (SiFI)\n\nYou will be given instructions before each task \n\nYou will be given an opportunity to have a rest after each sequence of a task\n\nPlease check the volume on your device to ensure it is loud enough\n\nYou can exit the experiment at any time by pressing the 'Escape' key on your keyboard\n\nPress the spacebar to continue",
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "beepFlashInstruc"
  beepFlashInstrucClock = new util.Clock();
  beepFlashTask = new visual.TextStim({
    win: psychoJS.window,
    name: 'beepFlashTask',
    text: 'This task is to ensure your sound and screen is functioning correctly.\n\nYou will hear one or two beeps\n                     or \nyou will see one or two flashes\n\nPress 1 for 1 beep/flash\nPress 2 for 2 beeps/flashes\n\nPress the spacebar to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "fixation_5"
  fixation_5Clock = new util.Clock();
  fix_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fix_5',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Initialize components for Routine "fixationp4"
  fixationp4Clock = new util.Clock();
  fix5_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fix5_3',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "beep_flash_SIFI"
  beep_flash_SIFIClock = new util.Clock();
  fixation_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_6',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  beep1_5 = new sound.Sound({
    win: psychoJS.window,
    value: 'A',
    secs: (- 1),
    });
  beep1_5.setVolume(1.0);
  circle1_6 = new visual.Polygon ({
    win: psychoJS.window, name: 'circle1_6', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -2, interpolate: true,
  });
  
  circle2_6 = new visual.Polygon ({
    win: psychoJS.window, name: 'circle2_6', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -3, interpolate: true,
  });
  
  // Run 'Begin Experiment' code from saveData2_2
  startTime = 0;
  
  // Initialize components for Routine "resp_1"
  resp_1Clock = new util.Clock();
  key_resp_9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  fixa = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixa',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "blank500"
  blank500Clock = new util.Clock();
  blank1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'blank1',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Initialize components for Routine "break4"
  break4Clock = new util.Clock();
  breakPracText_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'breakPracText_3',
    text: 'This is a break.\n\nPress the spacebar when you are ready to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_17 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "practiceInstruc"
  practiceInstrucClock = new util.Clock();
  practiceIn = new visual.TextStim({
    win: psychoJS.window,
    name: 'practiceIn',
    text: 'The SiFi involves a flash-beep sequence that is presented with a fixation point (+) in the centre of the screen\n\nLook only at the + \n\nA circle will flash below the fixation point either 1 or 2 times\n\nOne or two beeps may be accompanying the flash(es)\n\nIdentify whether one or two flashes were presented on the screen, after that please\n\n\n\nHere is your practice round\n\nPress the spacebar to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "fixationPr"
  fixationPrClock = new util.Clock();
  fix4_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fix4_2',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "practice_SIFI"
  practice_SIFIClock = new util.Clock();
  fixation_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_7',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  circle1_p = new visual.Polygon ({
    win: psychoJS.window, name: 'circle1_p', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -1, interpolate: true,
  });
  
  circle2_p = new visual.Polygon ({
    win: psychoJS.window, name: 'circle2_p', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -2, interpolate: true,
  });
  
  beep1_p = new sound.Sound({
    win: psychoJS.window,
    value: 'A',
    secs: (- 1),
    });
  beep1_p.setVolume(1.0);
  // Initialize components for Routine "prac_resp"
  prac_respClock = new util.Clock();
  text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_2',
    text: 'How many flashes did you see?\n\n1                2',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "blank500_2"
  blank500_2Clock = new util.Clock();
  blank1_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'blank1_2',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Initialize components for Routine "practiceBreak"
  practiceBreakClock = new util.Clock();
  breakPracText = new visual.TextStim({
    win: psychoJS.window,
    name: 'breakPracText',
    text: 'Take a break.\n\nWhen you are ready, press the spacebar to continue to the first SiFI task.\n\nPress the spacebar to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_13 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "SIFI_instruc"
  SIFI_instrucClock = new util.Clock();
  text_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_3',
    text: 'You will see a cross in the centre of the screen\n\nLook at the cross\n\nIdentify whether one or two flashes were presented\n\nPress the spacebar to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_14 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "fixation_b"
  fixation_bClock = new util.Clock();
  fix4_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fix4_3',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "SIFI_1"
  SIFI_1Clock = new util.Clock();
  fixation_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_8',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  circle1_5 = new visual.Polygon ({
    win: psychoJS.window, name: 'circle1_5', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -1, interpolate: true,
  });
  
  circle2_5 = new visual.Polygon ({
    win: psychoJS.window, name: 'circle2_5', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -2, interpolate: true,
  });
  
  beep1_6 = new sound.Sound({
    win: psychoJS.window,
    value: 'A',
    secs: (- 1),
    });
  beep1_6.setVolume(1.0);
  // Initialize components for Routine "SIFI_resp_1"
  SIFI_resp_1Clock = new util.Clock();
  key_resp_15 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  fixa_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixa_2',
    text: 'How many flashes did you see?\n\n1             2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "resp_conf"
  resp_confClock = new util.Clock();
  fixa_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixa_6',
    text: 'Please rate your certainty form 1 (not at all ) to 5 (full)\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  slider = new visual.Slider({
    win: psychoJS.window, name: 'slider',
    startValue: undefined,
    size: [1.0, 0.05], pos: [0, (- 0.1)], ori: 0.0, units: 'height',
    labels: undefined, fontSize: 0.03, ticks: [1, 2, 3, 4],
    granularity: 0.0, style: ["RATING"],
    color: new util.Color('LightGray'), markerColor: new util.Color([0.0, 0.0, 0.0]), lineColor: new util.Color('LightGray'), 
    opacity: undefined, fontFamily: 'Open Sans', bold: true, italic: false, depth: -1, 
    flip: false,
  });
  
  // Initialize components for Routine "blank500_3"
  blank500_3Clock = new util.Clock();
  blank1_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'blank1_3',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Initialize components for Routine "break_2"
  break_2Clock = new util.Clock();
  breakPracText_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'breakPracText_2',
    text: 'Take a break.\n\nPress the spacebar when you are ready to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_16 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "emotionInstruc"
  emotionInstrucClock = new util.Clock();
  visioninstruc = new visual.TextStim({
    win: psychoJS.window,
    name: 'visioninstruc',
    text: "You will first see a picture\n\nPlease respond whether you see one or two flashes\n\nRespond '1' for one flash and '2' for two flashes\n\nPress spacebar when you are ready to begin",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "imagefix2"
  imagefix2Clock = new util.Clock();
  fixation2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation2',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  image_3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_3', units : undefined, 
    image : 'images/Mask.jpg', mask : undefined,
    ori : 0.0, pos : [0, 0], size : [0.38, 0.52],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  // Initialize components for Routine "allPrime"
  allPrimeClock = new util.Clock();
  visualPrime_4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'visualPrime_4', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0.0, pos : [0, 0], size : [1, 1],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -1.0 
  });
  image = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0.0, pos : [0, 0], size : [0.38, 0.52],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -2.0 
  });
  // Initialize components for Routine "fixationp2"
  fixationp2Clock = new util.Clock();
  fix5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fix5',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  // Initialize components for Routine "SIFI2_2"
  SIFI2_2Clock = new util.Clock();
  fixation_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_3',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  circle1_3 = new visual.Polygon ({
    win: psychoJS.window, name: 'circle1_3', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -1, interpolate: true,
  });
  
  circle2_3 = new visual.Polygon ({
    win: psychoJS.window, name: 'circle2_3', 
    edges: 1000, size:[0.1, 0.1],
    ori: 0.0, pos: [0, (- 0.3)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: 1.0, depth: -2, interpolate: true,
  });
  
  beep1_3 = new sound.Sound({
    win: psychoJS.window,
    value: 'A',
    secs: (- 1),
    });
  beep1_3.setVolume(1.0);
  // Initialize components for Routine "SIFIResp"
  SIFIRespClock = new util.Clock();
  key_resp_5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  Options = new visual.TextStim({
    win: psychoJS.window,
    name: 'Options',
    text: 'How many flashes did you see?\n\n1             2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  Fixa_44 = new visual.TextStim({
    win: psychoJS.window,
    name: 'Fixa_44',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  // Initialize components for Routine "blank500_5"
  blank500_5Clock = new util.Clock();
  blank1_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'blank1_5',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Initialize components for Routine "instrucRate"
  instrucRateClock = new util.Clock();
  text_13 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_13',
    text: 'You will be shown the same images from the prior trials\n\nYou will be asked to rate the images using the scale presented in\n                             arousal and valence\n\nArousal indicates how much the image catches your attention\n\nValence is whether the image seems more positive, neutral, or negative to you\n\nThe scale is from 1 (least arousing, negative emotion) to 9 (very arousing, positive emotion)\n\nYou have 12 images to rate\n\nClick on the top right blue square to enter in your ratings and continue to the next picture\n\nClick the white box to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  whiteSquare = new visual.Rect ({
    win: psychoJS.window, name: 'whiteSquare', 
    width: [0.1, 0.1][0], height: [0.1, 0.1][1],
    ori: 0.0, pos: [0.35, (- 0.4)],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('white'),
    fillColor: new util.Color('white'),
    opacity: undefined, depth: -1, interpolate: true,
  });
  
  mouse_2 = new core.Mouse({
    win: psychoJS.window,
  });
  mouse_2.mouseClock = new util.Clock();
  // Initialize components for Routine "fix6"
  fix6Clock = new util.Clock();
  fixation3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation3',
    text: '+',
    font: 'Open Sans',
    units: undefined, 
    pos: [(- 0.3), 0.25], height: 0.1,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Initialize components for Routine "ratingTask"
  ratingTaskClock = new util.Clock();
  emotionImage = new visual.ImageStim({
    win : psychoJS.window,
    name : 'emotionImage', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0.0, pos : [(- 0.3), 0.25], size : [0.35, 0.48],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : 0.0 
  });
  arousalRating = new visual.Slider({
    win: psychoJS.window, name: 'arousalRating',
    startValue: undefined,
    size: [1, 0.04], pos: [0, (- 0.18)], ori: 0.0, units: 'height',
    labels: [1, 2, 3, 4, 5, 6, 7, 8, 9], fontSize: 0.025, ticks: [1, 2, 3, 4, 5, 6, 7, 8, 9],
    granularity: 0.0, style: ["RATING"],
    color: new util.Color('black'), markerColor: new util.Color('black'), lineColor: new util.Color('black'), 
    opacity: undefined, fontFamily: 'Open Sans', bold: true, italic: false, depth: -2, 
    flip: false,
  });
  
  arousalScale = new visual.ImageStim({
    win : psychoJS.window,
    name : 'arousalScale', units : undefined, 
    image : 'scale/arousalScale.png', mask : undefined,
    ori : 0.0, pos : [0, (- 0.12)], size : [1, 0.13],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -3.0 
  });
  valenceRating = new visual.Slider({
    win: psychoJS.window, name: 'valenceRating',
    startValue: undefined,
    size: [1, 0.04], pos: [0, (- 0.41)], ori: 0.0, units: 'height',
    labels: [1, 2, 3, 4, 5, 6, 7, 8, 9], fontSize: 0.025, ticks: [1, 2, 3, 4, 5, 6, 7, 8, 9],
    granularity: 0.0, style: ["RATING"],
    color: new util.Color('black'), markerColor: new util.Color('black'), lineColor: new util.Color('black'), 
    opacity: undefined, fontFamily: 'Open Sans', bold: true, italic: false, depth: -4, 
    flip: false,
  });
  
  valenceScale = new visual.ImageStim({
    win : psychoJS.window,
    name : 'valenceScale', units : undefined, 
    image : 'scale/valenceScale.png', mask : undefined,
    ori : 0.0, pos : [0, (- 0.35)], size : [1, 0.13],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -5.0 
  });
  keyText = new visual.TextStim({
    win: psychoJS.window,
    name: 'keyText',
    text: "Please rate the picture using BOTH the sliders. \nDon't think too much about it,\njust rate how you feel when watching it. \n\nClick on the black arrow when \nyou are finished rating this picture",
    font: 'Open Sans',
    units: undefined, 
    pos: [0.45, 0.35], height: 0.025,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),  opacity: undefined,
    depth: -6.0 
  });
  
  blueSquare = new visual.Rect ({
    win: psychoJS.window, name: 'blueSquare', 
    width: [0.1, 0.1][0], height: [0.1, 0.1][1],
    ori: 0.0, pos: [(- 0.35), 0.2],
    lineWidth: 1.0, 
    colorSpace: 'rgb',
    lineColor: new util.Color('blue'),
    fillColor: new util.Color('blue'),
    opacity: undefined, depth: -7, interpolate: true,
  });
  
  mouse = new core.Mouse({
    win: psychoJS.window,
  });
  mouse.mouseClock = new util.Clock();
  Next = new visual.ImageStim({
    win : psychoJS.window,
    name : 'Next', units : undefined, 
    image : 'scale/Next.png', mask : undefined,
    ori : 0.0, pos : [0.02, 0.15], size : [0.16, 0.12],
    color : new util.Color([1,1,1]), opacity : undefined,
    flipHoriz : false, flipVert : false,
    texRes : 128.0, interpolate : true, depth : -9.0 
  });
  // Initialize components for Routine "instrucRate_2"
  instrucRate_2Clock = new util.Clock();
  text_14 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_14',
    text: 'This is the final part of the experiment.\n\nYou will be asked to respond to some more questions\n\nClick the space bar to continue',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  key_resp_18 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Ques"
  QuesClock = new util.Clock();
  form_2 = new visual.Form({
    win : psychoJS.window, name:'form_2',
    items : 'demographics.csv',
    textHeight : 0.026,
    font : 'Arial',
    randomize : false,
    size : [1.6, 0.9],
    pos : [0, 0.03],
    style : 'dark',
    itemPadding : 0.001
  });
  button = new visual.ButtonStim({
    win: psychoJS.window,
    name: 'button',
    text: 'Submit',
    fillColor: [0.6471, 0.6706, 0.6706],
    borderColor: null,
    color: [(- 0.7569), (- 0.7647), (- 0.7412)],
    colorSpace: 'rgb',
    pos: [0.6, (- 0.45)],
    letterHeight: 0.05,
    size: [0.3, 0.06]
  });
  button.clock = new util.Clock();
  
  // Initialize components for Routine "endText"
  endTextClock = new util.Clock();
  text_12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_12',
    text: 'Thank you for participating',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.03,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: 0.0 
  });
  
  // Create some handy timers
  globalClock = new util.Clock();  // to track the time since experiment started
  routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
  
  return Scheduler.Event.NEXT;
}

function trials_2LoopBegin(trials_2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    trials_2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'imageFiles.xlsx',
      seed: undefined, name: 'trials_2'
    });
    psychoJS.experiment.addLoop(trials_2); // add the loop to the experiment
    currentLoop = trials_2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisTrial_2 of trials_2) {
      snapshot = trials_2.getSnapshot();
      trials_2LoopScheduler.add(importConditions(snapshot));
      trials_2LoopScheduler.add(code_2RoutineBegin(snapshot));
      trials_2LoopScheduler.add(code_2RoutineEachFrame());
      trials_2LoopScheduler.add(code_2RoutineEnd(snapshot));
      trials_2LoopScheduler.add(trials_2LoopEndIteration(trials_2LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function trials_2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(trials_2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function trials_2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function beepFlash_loopLoopBegin(beepFlash_loopLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    beepFlash_loop = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'beep_flash_only.xlsx',
      seed: undefined, name: 'beepFlash_loop'
    });
    psychoJS.experiment.addLoop(beepFlash_loop); // add the loop to the experiment
    currentLoop = beepFlash_loop;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisBeepFlash_loop of beepFlash_loop) {
      snapshot = beepFlash_loop.getSnapshot();
      beepFlash_loopLoopScheduler.add(importConditions(snapshot));
      beepFlash_loopLoopScheduler.add(fixationp4RoutineBegin(snapshot));
      beepFlash_loopLoopScheduler.add(fixationp4RoutineEachFrame());
      beepFlash_loopLoopScheduler.add(fixationp4RoutineEnd(snapshot));
      beepFlash_loopLoopScheduler.add(beep_flash_SIFIRoutineBegin(snapshot));
      beepFlash_loopLoopScheduler.add(beep_flash_SIFIRoutineEachFrame());
      beepFlash_loopLoopScheduler.add(beep_flash_SIFIRoutineEnd(snapshot));
      beepFlash_loopLoopScheduler.add(resp_1RoutineBegin(snapshot));
      beepFlash_loopLoopScheduler.add(resp_1RoutineEachFrame());
      beepFlash_loopLoopScheduler.add(resp_1RoutineEnd(snapshot));
      beepFlash_loopLoopScheduler.add(blank500RoutineBegin(snapshot));
      beepFlash_loopLoopScheduler.add(blank500RoutineEachFrame());
      beepFlash_loopLoopScheduler.add(blank500RoutineEnd(snapshot));
      beepFlash_loopLoopScheduler.add(blank500RoutineBegin(snapshot));
      beepFlash_loopLoopScheduler.add(blank500RoutineEachFrame());
      beepFlash_loopLoopScheduler.add(blank500RoutineEnd(snapshot));
      beepFlash_loopLoopScheduler.add(beepFlash_loopLoopEndIteration(beepFlash_loopLoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function beepFlash_loopLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(beepFlash_loop);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function beepFlash_loopLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function prac_sifiLoopBegin(prac_sifiLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    prac_sifi = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 2, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'practice_sifi.xlsx',
      seed: undefined, name: 'prac_sifi'
    });
    psychoJS.experiment.addLoop(prac_sifi); // add the loop to the experiment
    currentLoop = prac_sifi;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisPrac_sifi of prac_sifi) {
      snapshot = prac_sifi.getSnapshot();
      prac_sifiLoopScheduler.add(importConditions(snapshot));
      prac_sifiLoopScheduler.add(fixationPrRoutineBegin(snapshot));
      prac_sifiLoopScheduler.add(fixationPrRoutineEachFrame());
      prac_sifiLoopScheduler.add(fixationPrRoutineEnd(snapshot));
      prac_sifiLoopScheduler.add(practice_SIFIRoutineBegin(snapshot));
      prac_sifiLoopScheduler.add(practice_SIFIRoutineEachFrame());
      prac_sifiLoopScheduler.add(practice_SIFIRoutineEnd(snapshot));
      prac_sifiLoopScheduler.add(prac_respRoutineBegin(snapshot));
      prac_sifiLoopScheduler.add(prac_respRoutineEachFrame());
      prac_sifiLoopScheduler.add(prac_respRoutineEnd(snapshot));
      prac_sifiLoopScheduler.add(blank500_2RoutineBegin(snapshot));
      prac_sifiLoopScheduler.add(blank500_2RoutineEachFrame());
      prac_sifiLoopScheduler.add(blank500_2RoutineEnd(snapshot));
      prac_sifiLoopScheduler.add(prac_sifiLoopEndIteration(prac_sifiLoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function prac_sifiLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(prac_sifi);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function prac_sifiLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function baseline_loopLoopBegin(baseline_loopLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    baseline_loop = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'sifi_cond.xlsx',
      seed: undefined, name: 'baseline_loop'
    });
    psychoJS.experiment.addLoop(baseline_loop); // add the loop to the experiment
    currentLoop = baseline_loop;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisBaseline_loop of baseline_loop) {
      snapshot = baseline_loop.getSnapshot();
      baseline_loopLoopScheduler.add(importConditions(snapshot));
      baseline_loopLoopScheduler.add(fixation_bRoutineBegin(snapshot));
      baseline_loopLoopScheduler.add(fixation_bRoutineEachFrame());
      baseline_loopLoopScheduler.add(fixation_bRoutineEnd(snapshot));
      baseline_loopLoopScheduler.add(SIFI_1RoutineBegin(snapshot));
      baseline_loopLoopScheduler.add(SIFI_1RoutineEachFrame());
      baseline_loopLoopScheduler.add(SIFI_1RoutineEnd(snapshot));
      baseline_loopLoopScheduler.add(SIFI_resp_1RoutineBegin(snapshot));
      baseline_loopLoopScheduler.add(SIFI_resp_1RoutineEachFrame());
      baseline_loopLoopScheduler.add(SIFI_resp_1RoutineEnd(snapshot));
      baseline_loopLoopScheduler.add(resp_confRoutineBegin(snapshot));
      baseline_loopLoopScheduler.add(resp_confRoutineEachFrame());
      baseline_loopLoopScheduler.add(resp_confRoutineEnd(snapshot));
      baseline_loopLoopScheduler.add(blank500_3RoutineBegin(snapshot));
      baseline_loopLoopScheduler.add(blank500_3RoutineEachFrame());
      baseline_loopLoopScheduler.add(blank500_3RoutineEnd(snapshot));
      baseline_loopLoopScheduler.add(baseline_loopLoopEndIteration(baseline_loopLoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function baseline_loopLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(baseline_loop);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function baseline_loopLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function trials_5LoopBegin(trials_5LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    trials_5 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 2, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'sifi_cond2.xlsx',
      seed: undefined, name: 'trials_5'
    });
    psychoJS.experiment.addLoop(trials_5); // add the loop to the experiment
    currentLoop = trials_5;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisTrial_5 of trials_5) {
      snapshot = trials_5.getSnapshot();
      trials_5LoopScheduler.add(importConditions(snapshot));
      trials_5LoopScheduler.add(imagefix2RoutineBegin(snapshot));
      trials_5LoopScheduler.add(imagefix2RoutineEachFrame());
      trials_5LoopScheduler.add(imagefix2RoutineEnd(snapshot));
      trials_5LoopScheduler.add(allPrimeRoutineBegin(snapshot));
      trials_5LoopScheduler.add(allPrimeRoutineEachFrame());
      trials_5LoopScheduler.add(allPrimeRoutineEnd(snapshot));
      trials_5LoopScheduler.add(fixationp2RoutineBegin(snapshot));
      trials_5LoopScheduler.add(fixationp2RoutineEachFrame());
      trials_5LoopScheduler.add(fixationp2RoutineEnd(snapshot));
      trials_5LoopScheduler.add(SIFI2_2RoutineBegin(snapshot));
      trials_5LoopScheduler.add(SIFI2_2RoutineEachFrame());
      trials_5LoopScheduler.add(SIFI2_2RoutineEnd(snapshot));
      trials_5LoopScheduler.add(SIFIRespRoutineBegin(snapshot));
      trials_5LoopScheduler.add(SIFIRespRoutineEachFrame());
      trials_5LoopScheduler.add(SIFIRespRoutineEnd(snapshot));
      trials_5LoopScheduler.add(resp_confRoutineBegin(snapshot));
      trials_5LoopScheduler.add(resp_confRoutineEachFrame());
      trials_5LoopScheduler.add(resp_confRoutineEnd(snapshot));
      trials_5LoopScheduler.add(blank500_5RoutineBegin(snapshot));
      trials_5LoopScheduler.add(blank500_5RoutineEachFrame());
      trials_5LoopScheduler.add(blank500_5RoutineEnd(snapshot));
      trials_5LoopScheduler.add(trials_5LoopEndIteration(trials_5LoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function trials_5LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(trials_5);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function trials_5LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function rating_loopLoopBegin(rating_loopLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    rating_loop = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'rating_emotion.xlsx',
      seed: undefined, name: 'rating_loop'
    });
    psychoJS.experiment.addLoop(rating_loop); // add the loop to the experiment
    currentLoop = rating_loop;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisRating_loop of rating_loop) {
      snapshot = rating_loop.getSnapshot();
      rating_loopLoopScheduler.add(importConditions(snapshot));
      rating_loopLoopScheduler.add(fix6RoutineBegin(snapshot));
      rating_loopLoopScheduler.add(fix6RoutineEachFrame());
      rating_loopLoopScheduler.add(fix6RoutineEnd(snapshot));
      rating_loopLoopScheduler.add(ratingTaskRoutineBegin(snapshot));
      rating_loopLoopScheduler.add(ratingTaskRoutineEachFrame());
      rating_loopLoopScheduler.add(ratingTaskRoutineEnd(snapshot));
      rating_loopLoopScheduler.add(rating_loopLoopEndIteration(rating_loopLoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function rating_loopLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(rating_loop);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function rating_loopLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function trialsLoopBegin(trialsLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    trials = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 0, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'trials'
    });
    psychoJS.experiment.addLoop(trials); // add the loop to the experiment
    currentLoop = trials;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    for (const thisTrial of trials) {
      snapshot = trials.getSnapshot();
      trialsLoopScheduler.add(importConditions(snapshot));
      trialsLoopScheduler.add(instrucRate_2RoutineBegin(snapshot));
      trialsLoopScheduler.add(instrucRate_2RoutineEachFrame());
      trialsLoopScheduler.add(instrucRate_2RoutineEnd(snapshot));
      trialsLoopScheduler.add(QuesRoutineBegin(snapshot));
      trialsLoopScheduler.add(QuesRoutineEachFrame());
      trialsLoopScheduler.add(QuesRoutineEnd(snapshot));
      trialsLoopScheduler.add(trialsLoopEndIteration(trialsLoopScheduler, snapshot));
    }
    
    return Scheduler.Event.NEXT;
  }
}

async function trialsLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(trials);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}

function trialsLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}

function code_2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'code_2' ---
    t = 0;
    code_2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // Run 'Begin Routine' code from stimLoad
    for (var i, _pj_c = 0, _pj_a = util.range(10), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
        i = _pj_a[_pj_c];
        all_images.push(allImage);
    }
    
    // keep track of which components have finished
    code_2Components = [];
    
    for (const thisComponent of code_2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function code_2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'code_2' ---
    // get current time
    t = code_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of code_2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function code_2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'code_2' ---
    for (const thisComponent of code_2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "code_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function shuffle_stimRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'shuffle_stim' ---
    t = 0;
    shuffle_stimClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // keep track of which components have finished
    shuffle_stimComponents = [];
    
    for (const thisComponent of shuffle_stimComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function shuffle_stimRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'shuffle_stim' ---
    // get current time
    t = shuffle_stimClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of shuffle_stimComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function shuffle_stimRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'shuffle_stim' ---
    for (const thisComponent of shuffle_stimComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "shuffle_stim" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function hiTextRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'hiText' ---
    t = 0;
    hiTextClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_10.keys = undefined;
    key_resp_10.rt = undefined;
    _key_resp_10_allKeys = [];
    // keep track of which components have finished
    hiTextComponents = [];
    hiTextComponents.push(helloText);
    hiTextComponents.push(key_resp_10);
    
    for (const thisComponent of hiTextComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function hiTextRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'hiText' ---
    // get current time
    t = hiTextClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *helloText* updates
    if (t >= 0.0 && helloText.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      helloText.tStart = t;  // (not accounting for frame time here)
      helloText.frameNStart = frameN;  // exact frame index
      
      helloText.setAutoDraw(true);
    }

    
    // *key_resp_10* updates
    if (t >= 0.0 && key_resp_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_10.tStart = t;  // (not accounting for frame time here)
      key_resp_10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_10.clearEvents(); });
    }

    if (key_resp_10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_10.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_10_allKeys = _key_resp_10_allKeys.concat(theseKeys);
      if (_key_resp_10_allKeys.length > 0) {
        key_resp_10.keys = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].name;  // just the last key pressed
        key_resp_10.rt = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of hiTextComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function hiTextRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'hiText' ---
    for (const thisComponent of hiTextComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_10.stop();
    // the Routine "hiText" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function beepFlashInstrucRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'beepFlashInstruc' ---
    t = 0;
    beepFlashInstrucClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_4.keys = undefined;
    key_resp_4.rt = undefined;
    _key_resp_4_allKeys = [];
    // keep track of which components have finished
    beepFlashInstrucComponents = [];
    beepFlashInstrucComponents.push(beepFlashTask);
    beepFlashInstrucComponents.push(key_resp_4);
    
    for (const thisComponent of beepFlashInstrucComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function beepFlashInstrucRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'beepFlashInstruc' ---
    // get current time
    t = beepFlashInstrucClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *beepFlashTask* updates
    if (t >= 0.0 && beepFlashTask.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      beepFlashTask.tStart = t;  // (not accounting for frame time here)
      beepFlashTask.frameNStart = frameN;  // exact frame index
      
      beepFlashTask.setAutoDraw(true);
    }

    
    // *key_resp_4* updates
    if (t >= 0.0 && key_resp_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_4.tStart = t;  // (not accounting for frame time here)
      key_resp_4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_4.clearEvents(); });
    }

    if (key_resp_4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_4.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_4_allKeys = _key_resp_4_allKeys.concat(theseKeys);
      if (_key_resp_4_allKeys.length > 0) {
        key_resp_4.keys = _key_resp_4_allKeys[_key_resp_4_allKeys.length - 1].name;  // just the last key pressed
        key_resp_4.rt = _key_resp_4_allKeys[_key_resp_4_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of beepFlashInstrucComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function beepFlashInstrucRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'beepFlashInstruc' ---
    for (const thisComponent of beepFlashInstrucComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_4.stop();
    // the Routine "beepFlashInstruc" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function fixation_5RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'fixation_5' ---
    t = 0;
    fixation_5Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    fixation_5Components = [];
    fixation_5Components.push(fix_5);
    
    for (const thisComponent of fixation_5Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function fixation_5RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'fixation_5' ---
    // get current time
    t = fixation_5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fix_5* updates
    if (t >= 0.0 && fix_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fix_5.tStart = t;  // (not accounting for frame time here)
      fix_5.frameNStart = frameN;  // exact frame index
      
      fix_5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fix_5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fix_5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of fixation_5Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function fixation_5RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'fixation_5' ---
    for (const thisComponent of fixation_5Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function fixationp4RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'fixationp4' ---
    t = 0;
    fixationp4Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // Run 'Begin Routine' code from ISI_1
    //random number between 500-750ms
    ISI = random() * (1.1 - .5) + .500
    ISI = round(ISI, 1) // round to 1 decimal place
    thisExp.addData('ISI', ISI)
    
    // keep track of which components have finished
    fixationp4Components = [];
    fixationp4Components.push(fix5_3);
    
    for (const thisComponent of fixationp4Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function fixationp4RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'fixationp4' ---
    // get current time
    t = fixationp4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fix5_3* updates
    if (t >= 0 && fix5_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fix5_3.tStart = t;  // (not accounting for frame time here)
      fix5_3.frameNStart = frameN;  // exact frame index
      
      fix5_3.setAutoDraw(true);
    }

    frameRemains = 0 + ISI - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fix5_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fix5_3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of fixationp4Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function fixationp4RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'fixationp4' ---
    for (const thisComponent of fixationp4Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "fixationp4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function beep_flash_SIFIRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'beep_flash_SIFI' ---
    t = 0;
    beep_flash_SIFIClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    beep1_5 = new sound.Sound({
    win: psychoJS.window,
    value: beepSound,
    secs: -1,
    });
    beep1_5.setVolume(1.0);
    circle1_6.setOpacity(opacity);
    circle2_6.setOpacity(opacity2);
    // Run 'Begin Routine' code from saveData2_2
    (key_resp_9.status === NOT_STARTED);
    if ((beep1_5.status === PsychoJS.Status.FINISHED)) {
        (key_resp_9.status === PsychoJS.Status.STARTED);
    } else {
        if (((circle1_6.status === PsychoJS.Status.FINISHED) && (circle2_6.status === PsychoJS.Status.FINISHED))) {
            (key_resp_9.status === PsychoJS.Status.STARTED);
        }
    }
    
    // keep track of which components have finished
    beep_flash_SIFIComponents = [];
    beep_flash_SIFIComponents.push(fixation_6);
    beep_flash_SIFIComponents.push(beep1_5);
    beep_flash_SIFIComponents.push(circle1_6);
    beep_flash_SIFIComponents.push(circle2_6);
    
    for (const thisComponent of beep_flash_SIFIComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function beep_flash_SIFIRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'beep_flash_SIFI' ---
    // get current time
    t = beep_flash_SIFIClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_6* updates
    if (t >= 0 && fixation_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_6.tStart = t;  // (not accounting for frame time here)
      fixation_6.frameNStart = frameN;  // exact frame index
      
      fixation_6.setAutoDraw(true);
    }

    if (fixation_6.status === PsychoJS.Status.STARTED && Boolean(((circle2_6.status == FINISHED) && (beep1_5.status == FINISHED)))) {
      fixation_6.setAutoDraw(false);
    }
    // start/stop beep1_5
    if (t >= beepOnset && beep1_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      beep1_5.tStart = t;  // (not accounting for frame time here)
      beep1_5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ beep1_5.play(); });  // screen flip
      beep1_5.status = PsychoJS.Status.STARTED;
    }
    if (t >= (beep1_5.getDuration() + beep1_5.tStart)     && beep1_5.status === PsychoJS.Status.STARTED) {
      beep1_5.stop();  // stop the sound (if longer than duration)
      beep1_5.status = PsychoJS.Status.FINISHED;
    }
    
    // *circle1_6* updates
    if (t >= flashOnset && circle1_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle1_6.tStart = t;  // (not accounting for frame time here)
      circle1_6.frameNStart = frameN;  // exact frame index
      
      circle1_6.setAutoDraw(true);
    }

    if (circle1_6.status === PsychoJS.Status.STARTED && frameN >= (circle1_6.frameNStart + 0.0016)) {
      circle1_6.setAutoDraw(false);
    }
    
    // *circle2_6* updates
    if (t >= (flashOnset + SOA) && circle2_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle2_6.tStart = t;  // (not accounting for frame time here)
      circle2_6.frameNStart = frameN;  // exact frame index
      
      circle2_6.setAutoDraw(true);
    }

    if (circle2_6.status === PsychoJS.Status.STARTED && frameN >= (circle2_6.frameNStart + 0.0016)) {
      circle2_6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of beep_flash_SIFIComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function beep_flash_SIFIRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'beep_flash_SIFI' ---
    for (const thisComponent of beep_flash_SIFIComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    beep1_5.stop();  // ensure sound has stopped at end of routine
    // Run 'End Routine' code from saveData2_2
    psychoJS.experiment.addData("trial", trial);
    psychoJS.experiment.addData("SOA", SOA);
    
    // the Routine "beep_flash_SIFI" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function resp_1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'resp_1' ---
    t = 0;
    resp_1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_9.keys = undefined;
    key_resp_9.rt = undefined;
    _key_resp_9_allKeys = [];
    // keep track of which components have finished
    resp_1Components = [];
    resp_1Components.push(key_resp_9);
    resp_1Components.push(fixa);
    
    for (const thisComponent of resp_1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function resp_1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'resp_1' ---
    // get current time
    t = resp_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *key_resp_9* updates
    if (t >= 0 && key_resp_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_9.tStart = t;  // (not accounting for frame time here)
      key_resp_9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_9.clearEvents(); });
    }

    if (key_resp_9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_9.getKeys({keyList: ['1', '2'], waitRelease: false});
      _key_resp_9_allKeys = _key_resp_9_allKeys.concat(theseKeys);
      if (_key_resp_9_allKeys.length > 0) {
        key_resp_9.keys = _key_resp_9_allKeys[0].name;  // just the first key pressed
        key_resp_9.rt = _key_resp_9_allKeys[0].rt;
        // was this correct?
        if (key_resp_9.keys == corrAns) {
            key_resp_9.corr = 1;
        } else {
            key_resp_9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *fixa* updates
    if (t >= 0.0 && fixa.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixa.tStart = t;  // (not accounting for frame time here)
      fixa.frameNStart = frameN;  // exact frame index
      
      fixa.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of resp_1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function resp_1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'resp_1' ---
    for (const thisComponent of resp_1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // was no response the correct answer?!
    if (key_resp_9.keys === undefined) {
      if (['None','none',undefined].includes(corrAns)) {
         key_resp_9.corr = 1;  // correct non-response
      } else {
         key_resp_9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_9.corr, level);
    }
    psychoJS.experiment.addData('key_resp_9.keys', key_resp_9.keys);
    psychoJS.experiment.addData('key_resp_9.corr', key_resp_9.corr);
    if (typeof key_resp_9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_9.rt', key_resp_9.rt);
        routineTimer.reset();
        }
    
    key_resp_9.stop();
    // the Routine "resp_1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function blank500RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'blank500' ---
    t = 0;
    blank500Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    blank500Components = [];
    blank500Components.push(blank1);
    
    for (const thisComponent of blank500Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function blank500RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'blank500' ---
    // get current time
    t = blank500Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *blank1* updates
    if (t >= 0.0 && blank1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      blank1.tStart = t;  // (not accounting for frame time here)
      blank1.frameNStart = frameN;  // exact frame index
      
      blank1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (blank1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      blank1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of blank500Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function blank500RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'blank500' ---
    for (const thisComponent of blank500Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function break4RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'break4' ---
    t = 0;
    break4Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_17.keys = undefined;
    key_resp_17.rt = undefined;
    _key_resp_17_allKeys = [];
    // keep track of which components have finished
    break4Components = [];
    break4Components.push(breakPracText_3);
    break4Components.push(key_resp_17);
    
    for (const thisComponent of break4Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function break4RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'break4' ---
    // get current time
    t = break4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *breakPracText_3* updates
    if (t >= 0.0 && breakPracText_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      breakPracText_3.tStart = t;  // (not accounting for frame time here)
      breakPracText_3.frameNStart = frameN;  // exact frame index
      
      breakPracText_3.setAutoDraw(true);
    }

    
    // *key_resp_17* updates
    if (t >= 0.0 && key_resp_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_17.tStart = t;  // (not accounting for frame time here)
      key_resp_17.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_17.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_17.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_17.clearEvents(); });
    }

    if (key_resp_17.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_17.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_17_allKeys = _key_resp_17_allKeys.concat(theseKeys);
      if (_key_resp_17_allKeys.length > 0) {
        key_resp_17.keys = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].name;  // just the last key pressed
        key_resp_17.rt = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of break4Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function break4RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'break4' ---
    for (const thisComponent of break4Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_17.stop();
    // the Routine "break4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function practiceInstrucRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'practiceInstruc' ---
    t = 0;
    practiceInstrucClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_11.keys = undefined;
    key_resp_11.rt = undefined;
    _key_resp_11_allKeys = [];
    // keep track of which components have finished
    practiceInstrucComponents = [];
    practiceInstrucComponents.push(practiceIn);
    practiceInstrucComponents.push(key_resp_11);
    
    for (const thisComponent of practiceInstrucComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function practiceInstrucRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'practiceInstruc' ---
    // get current time
    t = practiceInstrucClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *practiceIn* updates
    if (t >= 0.0 && practiceIn.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      practiceIn.tStart = t;  // (not accounting for frame time here)
      practiceIn.frameNStart = frameN;  // exact frame index
      
      practiceIn.setAutoDraw(true);
    }

    
    // *key_resp_11* updates
    if (t >= 0.0 && key_resp_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_11.tStart = t;  // (not accounting for frame time here)
      key_resp_11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_11.clearEvents(); });
    }

    if (key_resp_11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_11.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_11_allKeys = _key_resp_11_allKeys.concat(theseKeys);
      if (_key_resp_11_allKeys.length > 0) {
        key_resp_11.keys = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].name;  // just the last key pressed
        key_resp_11.rt = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of practiceInstrucComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function practiceInstrucRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'practiceInstruc' ---
    for (const thisComponent of practiceInstrucComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_11.stop();
    // the Routine "practiceInstruc" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function fixationPrRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'fixationPr' ---
    t = 0;
    fixationPrClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // Run 'Begin Routine' code from ISI_2
    //random number between 1100-500ms
    ISI = random() * (1.1 - .5) + .500
    ISI = round(ISI, 1) 
    thisExp.addData('ISI', ISI)
    
    // keep track of which components have finished
    fixationPrComponents = [];
    fixationPrComponents.push(fix4_2);
    
    for (const thisComponent of fixationPrComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function fixationPrRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'fixationPr' ---
    // get current time
    t = fixationPrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fix4_2* updates
    if (t >= 0.0 && fix4_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fix4_2.tStart = t;  // (not accounting for frame time here)
      fix4_2.frameNStart = frameN;  // exact frame index
      
      fix4_2.setAutoDraw(true);
    }

    frameRemains = 0.0 + ISI - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fix4_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fix4_2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of fixationPrComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function fixationPrRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'fixationPr' ---
    for (const thisComponent of fixationPrComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "fixationPr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function practice_SIFIRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'practice_SIFI' ---
    t = 0;
    practice_SIFIClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    circle1_p.setOpacity(opacity);
    circle2_p.setOpacity(opacity2);
    beep1_p = new sound.Sound({
    win: psychoJS.window,
    value: beepSound,
    secs: -1,
    });
    beep1_p.setVolume(1.0);
    // keep track of which components have finished
    practice_SIFIComponents = [];
    practice_SIFIComponents.push(fixation_7);
    practice_SIFIComponents.push(circle1_p);
    practice_SIFIComponents.push(circle2_p);
    practice_SIFIComponents.push(beep1_p);
    
    for (const thisComponent of practice_SIFIComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function practice_SIFIRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'practice_SIFI' ---
    // get current time
    t = practice_SIFIClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_7* updates
    if (t >= 0.0 && fixation_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_7.tStart = t;  // (not accounting for frame time here)
      fixation_7.frameNStart = frameN;  // exact frame index
      
      fixation_7.setAutoDraw(true);
    }

    if (fixation_7.status === PsychoJS.Status.STARTED && Boolean(((circle2_p.status == FINISHED) && (beep1_p.status == FINISHED)))) {
      fixation_7.setAutoDraw(false);
    }
    
    // *circle1_p* updates
    if (t >= flashOnset && circle1_p.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle1_p.tStart = t;  // (not accounting for frame time here)
      circle1_p.frameNStart = frameN;  // exact frame index
      
      circle1_p.setAutoDraw(true);
    }

    if (circle1_p.status === PsychoJS.Status.STARTED && frameN >= (circle1_p.frameNStart + 0.0016)) {
      circle1_p.setAutoDraw(false);
    }
    
    // *circle2_p* updates
    if (t >= (flashOnset + SOA) && circle2_p.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle2_p.tStart = t;  // (not accounting for frame time here)
      circle2_p.frameNStart = frameN;  // exact frame index
      
      circle2_p.setAutoDraw(true);
    }

    if (circle2_p.status === PsychoJS.Status.STARTED && frameN >= (circle2_p.frameNStart + 0.0016)) {
      circle2_p.setAutoDraw(false);
    }
    // start/stop beep1_p
    if (t >= beepOnset && beep1_p.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      beep1_p.tStart = t;  // (not accounting for frame time here)
      beep1_p.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ beep1_p.play(); });  // screen flip
      beep1_p.status = PsychoJS.Status.STARTED;
    }
    if (t >= (beep1_p.getDuration() + beep1_p.tStart)     && beep1_p.status === PsychoJS.Status.STARTED) {
      beep1_p.stop();  // stop the sound (if longer than duration)
      beep1_p.status = PsychoJS.Status.FINISHED;
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of practice_SIFIComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function practice_SIFIRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'practice_SIFI' ---
    for (const thisComponent of practice_SIFIComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    beep1_p.stop();  // ensure sound has stopped at end of routine
    // Run 'End Routine' code from saveData5
    psychoJS.experiment.addData("trial", trial);
    psychoJS.experiment.addData("SOA", SOA);
    
    // the Routine "practice_SIFI" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function prac_respRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'prac_resp' ---
    t = 0;
    prac_respClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_12.keys = undefined;
    key_resp_12.rt = undefined;
    _key_resp_12_allKeys = [];
    // keep track of which components have finished
    prac_respComponents = [];
    prac_respComponents.push(text_2);
    prac_respComponents.push(key_resp_12);
    
    for (const thisComponent of prac_respComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function prac_respRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'prac_resp' ---
    // get current time
    t = prac_respClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_2* updates
    if (t >= 0 && text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_2.tStart = t;  // (not accounting for frame time here)
      text_2.frameNStart = frameN;  // exact frame index
      
      text_2.setAutoDraw(true);
    }

    
    // *key_resp_12* updates
    if (t >= 0 && key_resp_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_12.tStart = t;  // (not accounting for frame time here)
      key_resp_12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_12.clearEvents(); });
    }

    if (key_resp_12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_12.getKeys({keyList: ['1', '2'], waitRelease: false});
      _key_resp_12_allKeys = _key_resp_12_allKeys.concat(theseKeys);
      if (_key_resp_12_allKeys.length > 0) {
        key_resp_12.keys = _key_resp_12_allKeys[0].name;  // just the first key pressed
        key_resp_12.rt = _key_resp_12_allKeys[0].rt;
        // was this correct?
        if (key_resp_12.keys == corrAns) {
            key_resp_12.corr = 1;
        } else {
            key_resp_12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of prac_respComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function prac_respRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'prac_resp' ---
    for (const thisComponent of prac_respComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // was no response the correct answer?!
    if (key_resp_12.keys === undefined) {
      if (['None','none',undefined].includes(corrAns)) {
         key_resp_12.corr = 1;  // correct non-response
      } else {
         key_resp_12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_12.corr, level);
    }
    psychoJS.experiment.addData('key_resp_12.keys', key_resp_12.keys);
    psychoJS.experiment.addData('key_resp_12.corr', key_resp_12.corr);
    if (typeof key_resp_12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_12.rt', key_resp_12.rt);
        routineTimer.reset();
        }
    
    key_resp_12.stop();
    // the Routine "prac_resp" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function blank500_2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'blank500_2' ---
    t = 0;
    blank500_2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    blank500_2Components = [];
    blank500_2Components.push(blank1_2);
    
    for (const thisComponent of blank500_2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function blank500_2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'blank500_2' ---
    // get current time
    t = blank500_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *blank1_2* updates
    if (t >= 0.0 && blank1_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      blank1_2.tStart = t;  // (not accounting for frame time here)
      blank1_2.frameNStart = frameN;  // exact frame index
      
      blank1_2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (blank1_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      blank1_2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of blank500_2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function blank500_2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'blank500_2' ---
    for (const thisComponent of blank500_2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function practiceBreakRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'practiceBreak' ---
    t = 0;
    practiceBreakClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_13.keys = undefined;
    key_resp_13.rt = undefined;
    _key_resp_13_allKeys = [];
    // keep track of which components have finished
    practiceBreakComponents = [];
    practiceBreakComponents.push(breakPracText);
    practiceBreakComponents.push(key_resp_13);
    
    for (const thisComponent of practiceBreakComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function practiceBreakRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'practiceBreak' ---
    // get current time
    t = practiceBreakClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *breakPracText* updates
    if (t >= 0.0 && breakPracText.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      breakPracText.tStart = t;  // (not accounting for frame time here)
      breakPracText.frameNStart = frameN;  // exact frame index
      
      breakPracText.setAutoDraw(true);
    }

    
    // *key_resp_13* updates
    if (t >= 0.0 && key_resp_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_13.tStart = t;  // (not accounting for frame time here)
      key_resp_13.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_13.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_13.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_13.clearEvents(); });
    }

    if (key_resp_13.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_13.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_13_allKeys = _key_resp_13_allKeys.concat(theseKeys);
      if (_key_resp_13_allKeys.length > 0) {
        key_resp_13.keys = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].name;  // just the last key pressed
        key_resp_13.rt = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of practiceBreakComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function practiceBreakRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'practiceBreak' ---
    for (const thisComponent of practiceBreakComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_13.stop();
    // the Routine "practiceBreak" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function SIFI_instrucRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'SIFI_instruc' ---
    t = 0;
    SIFI_instrucClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_14.keys = undefined;
    key_resp_14.rt = undefined;
    _key_resp_14_allKeys = [];
    // keep track of which components have finished
    SIFI_instrucComponents = [];
    SIFI_instrucComponents.push(text_3);
    SIFI_instrucComponents.push(key_resp_14);
    
    for (const thisComponent of SIFI_instrucComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function SIFI_instrucRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'SIFI_instruc' ---
    // get current time
    t = SIFI_instrucClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_3* updates
    if (t >= 0.0 && text_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_3.tStart = t;  // (not accounting for frame time here)
      text_3.frameNStart = frameN;  // exact frame index
      
      text_3.setAutoDraw(true);
    }

    
    // *key_resp_14* updates
    if (t >= 0.0 && key_resp_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_14.tStart = t;  // (not accounting for frame time here)
      key_resp_14.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_14.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_14.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_14.clearEvents(); });
    }

    if (key_resp_14.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_14.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_14_allKeys = _key_resp_14_allKeys.concat(theseKeys);
      if (_key_resp_14_allKeys.length > 0) {
        key_resp_14.keys = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].name;  // just the last key pressed
        key_resp_14.rt = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of SIFI_instrucComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function SIFI_instrucRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'SIFI_instruc' ---
    for (const thisComponent of SIFI_instrucComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_14.stop();
    // the Routine "SIFI_instruc" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function fixation_bRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'fixation_b' ---
    t = 0;
    fixation_bClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // Run 'Begin Routine' code from ISI_3
    ISI = random() * (1.1 - .5) + .500
    ISI = round(ISI, 1) 
    thisExp.addData('ISI', ISI)
    
    // keep track of which components have finished
    fixation_bComponents = [];
    fixation_bComponents.push(fix4_3);
    
    for (const thisComponent of fixation_bComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function fixation_bRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'fixation_b' ---
    // get current time
    t = fixation_bClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fix4_3* updates
    if (t >= 0.0 && fix4_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fix4_3.tStart = t;  // (not accounting for frame time here)
      fix4_3.frameNStart = frameN;  // exact frame index
      
      fix4_3.setAutoDraw(true);
    }

    frameRemains = 0.0 + ISI - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fix4_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fix4_3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of fixation_bComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function fixation_bRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'fixation_b' ---
    for (const thisComponent of fixation_bComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "fixation_b" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function SIFI_1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'SIFI_1' ---
    t = 0;
    SIFI_1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    circle1_5.setOpacity(opacity);
    circle2_5.setOpacity(opacity2);
    beep1_6 = new sound.Sound({
    win: psychoJS.window,
    value: beepSound,
    secs: -1,
    });
    beep1_6.setVolume(1.0);
    // keep track of which components have finished
    SIFI_1Components = [];
    SIFI_1Components.push(fixation_8);
    SIFI_1Components.push(circle1_5);
    SIFI_1Components.push(circle2_5);
    SIFI_1Components.push(beep1_6);
    
    for (const thisComponent of SIFI_1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function SIFI_1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'SIFI_1' ---
    // get current time
    t = SIFI_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_8* updates
    if (t >= 0.0 && fixation_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_8.tStart = t;  // (not accounting for frame time here)
      fixation_8.frameNStart = frameN;  // exact frame index
      
      fixation_8.setAutoDraw(true);
    }

    if (fixation_8.status === PsychoJS.Status.STARTED && Boolean(((circle2_5.status == FINISHED) && (beep1_6.status == FINISHED)))) {
      fixation_8.setAutoDraw(false);
    }
    
    // *circle1_5* updates
    if (t >= flashOnset && circle1_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle1_5.tStart = t;  // (not accounting for frame time here)
      circle1_5.frameNStart = frameN;  // exact frame index
      
      circle1_5.setAutoDraw(true);
    }

    if (circle1_5.status === PsychoJS.Status.STARTED && frameN >= (circle1_5.frameNStart + 0.0016)) {
      circle1_5.setAutoDraw(false);
    }
    
    // *circle2_5* updates
    if (t >= (flashOnset + SOA) && circle2_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle2_5.tStart = t;  // (not accounting for frame time here)
      circle2_5.frameNStart = frameN;  // exact frame index
      
      circle2_5.setAutoDraw(true);
    }

    if (circle2_5.status === PsychoJS.Status.STARTED && frameN >= (circle2_5.frameNStart + 0.0016)) {
      circle2_5.setAutoDraw(false);
    }
    // start/stop beep1_6
    if (t >= beepOnset && beep1_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      beep1_6.tStart = t;  // (not accounting for frame time here)
      beep1_6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ beep1_6.play(); });  // screen flip
      beep1_6.status = PsychoJS.Status.STARTED;
    }
    if (t >= (beep1_6.getDuration() + beep1_6.tStart)     && beep1_6.status === PsychoJS.Status.STARTED) {
      beep1_6.stop();  // stop the sound (if longer than duration)
      beep1_6.status = PsychoJS.Status.FINISHED;
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of SIFI_1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function SIFI_1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'SIFI_1' ---
    for (const thisComponent of SIFI_1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    beep1_6.stop();  // ensure sound has stopped at end of routine
    // Run 'End Routine' code from saveData1
    psychoJS.experiment.addData("trial", trial);
    psychoJS.experiment.addData("SOA", SOA);
    
    // the Routine "SIFI_1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function SIFI_resp_1RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'SIFI_resp_1' ---
    t = 0;
    SIFI_resp_1Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_15.keys = undefined;
    key_resp_15.rt = undefined;
    _key_resp_15_allKeys = [];
    // keep track of which components have finished
    SIFI_resp_1Components = [];
    SIFI_resp_1Components.push(key_resp_15);
    SIFI_resp_1Components.push(fixa_2);
    
    for (const thisComponent of SIFI_resp_1Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function SIFI_resp_1RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'SIFI_resp_1' ---
    // get current time
    t = SIFI_resp_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *key_resp_15* updates
    if (t >= 0 && key_resp_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_15.tStart = t;  // (not accounting for frame time here)
      key_resp_15.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_15.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_15.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_15.clearEvents(); });
    }

    if (key_resp_15.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_15.getKeys({keyList: ['1', '2'], waitRelease: false});
      _key_resp_15_allKeys = _key_resp_15_allKeys.concat(theseKeys);
      if (_key_resp_15_allKeys.length > 0) {
        key_resp_15.keys = _key_resp_15_allKeys[0].name;  // just the first key pressed
        key_resp_15.rt = _key_resp_15_allKeys[0].rt;
        // was this correct?
        if (key_resp_15.keys == corrAns) {
            key_resp_15.corr = 1;
        } else {
            key_resp_15.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *fixa_2* updates
    if (t >= 0.0 && fixa_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixa_2.tStart = t;  // (not accounting for frame time here)
      fixa_2.frameNStart = frameN;  // exact frame index
      
      fixa_2.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of SIFI_resp_1Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function SIFI_resp_1RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'SIFI_resp_1' ---
    for (const thisComponent of SIFI_resp_1Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // was no response the correct answer?!
    if (key_resp_15.keys === undefined) {
      if (['None','none',undefined].includes(corrAns)) {
         key_resp_15.corr = 1;  // correct non-response
      } else {
         key_resp_15.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_15.corr, level);
    }
    psychoJS.experiment.addData('key_resp_15.keys', key_resp_15.keys);
    psychoJS.experiment.addData('key_resp_15.corr', key_resp_15.corr);
    if (typeof key_resp_15.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_15.rt', key_resp_15.rt);
        routineTimer.reset();
        }
    
    key_resp_15.stop();
    // the Routine "SIFI_resp_1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function resp_confRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'resp_conf' ---
    t = 0;
    resp_confClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    slider.reset()
    // keep track of which components have finished
    resp_confComponents = [];
    resp_confComponents.push(fixa_6);
    resp_confComponents.push(slider);
    
    for (const thisComponent of resp_confComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function resp_confRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'resp_conf' ---
    // get current time
    t = resp_confClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixa_6* updates
    if (t >= 0.0 && fixa_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixa_6.tStart = t;  // (not accounting for frame time here)
      fixa_6.frameNStart = frameN;  // exact frame index
      
      fixa_6.setAutoDraw(true);
    }

    
    // *slider* updates
    if (t >= 0.0 && slider.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      slider.tStart = t;  // (not accounting for frame time here)
      slider.frameNStart = frameN;  // exact frame index
      
      slider.setAutoDraw(true);
    }

    
    // Check slider for response to end routine
    if (slider.getRating() !== undefined && slider.status === PsychoJS.Status.STARTED) {
      continueRoutine = false; }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of resp_confComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function resp_confRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'resp_conf' ---
    for (const thisComponent of resp_confComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    psychoJS.experiment.addData('slider.response', slider.getRating());
    psychoJS.experiment.addData('slider.rt', slider.getRT());
    // the Routine "resp_conf" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function blank500_3RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'blank500_3' ---
    t = 0;
    blank500_3Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    blank500_3Components = [];
    blank500_3Components.push(blank1_3);
    
    for (const thisComponent of blank500_3Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function blank500_3RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'blank500_3' ---
    // get current time
    t = blank500_3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *blank1_3* updates
    if (t >= 0.0 && blank1_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      blank1_3.tStart = t;  // (not accounting for frame time here)
      blank1_3.frameNStart = frameN;  // exact frame index
      
      blank1_3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (blank1_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      blank1_3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of blank500_3Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function blank500_3RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'blank500_3' ---
    for (const thisComponent of blank500_3Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function break_2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'break_2' ---
    t = 0;
    break_2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_16.keys = undefined;
    key_resp_16.rt = undefined;
    _key_resp_16_allKeys = [];
    // keep track of which components have finished
    break_2Components = [];
    break_2Components.push(breakPracText_2);
    break_2Components.push(key_resp_16);
    
    for (const thisComponent of break_2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function break_2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'break_2' ---
    // get current time
    t = break_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *breakPracText_2* updates
    if (t >= 0.0 && breakPracText_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      breakPracText_2.tStart = t;  // (not accounting for frame time here)
      breakPracText_2.frameNStart = frameN;  // exact frame index
      
      breakPracText_2.setAutoDraw(true);
    }

    
    // *key_resp_16* updates
    if (t >= 0.0 && key_resp_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_16.tStart = t;  // (not accounting for frame time here)
      key_resp_16.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_16.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_16.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_16.clearEvents(); });
    }

    if (key_resp_16.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_16.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_16_allKeys = _key_resp_16_allKeys.concat(theseKeys);
      if (_key_resp_16_allKeys.length > 0) {
        key_resp_16.keys = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].name;  // just the last key pressed
        key_resp_16.rt = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of break_2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function break_2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'break_2' ---
    for (const thisComponent of break_2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp_16.stop();
    // the Routine "break_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function emotionInstrucRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'emotionInstruc' ---
    t = 0;
    emotionInstrucClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp.keys = undefined;
    key_resp.rt = undefined;
    _key_resp_allKeys = [];
    // keep track of which components have finished
    emotionInstrucComponents = [];
    emotionInstrucComponents.push(visioninstruc);
    emotionInstrucComponents.push(key_resp);
    
    for (const thisComponent of emotionInstrucComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function emotionInstrucRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'emotionInstruc' ---
    // get current time
    t = emotionInstrucClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *visioninstruc* updates
    if (t >= 0.0 && visioninstruc.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      visioninstruc.tStart = t;  // (not accounting for frame time here)
      visioninstruc.frameNStart = frameN;  // exact frame index
      
      visioninstruc.setAutoDraw(true);
    }

    
    // *key_resp* updates
    if (t >= 0.0 && key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp.tStart = t;  // (not accounting for frame time here)
      key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp.clearEvents(); });
    }

    if (key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_allKeys = _key_resp_allKeys.concat(theseKeys);
      if (_key_resp_allKeys.length > 0) {
        key_resp.keys = _key_resp_allKeys[_key_resp_allKeys.length - 1].name;  // just the last key pressed
        key_resp.rt = _key_resp_allKeys[_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of emotionInstrucComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function emotionInstrucRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'emotionInstruc' ---
    for (const thisComponent of emotionInstrucComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    key_resp.stop();
    // the Routine "emotionInstruc" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function imagefix2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'imagefix2' ---
    t = 0;
    imagefix2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    imagefix2Components = [];
    imagefix2Components.push(fixation2);
    imagefix2Components.push(image_3);
    
    for (const thisComponent of imagefix2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function imagefix2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'imagefix2' ---
    // get current time
    t = imagefix2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation2* updates
    if (t >= 0.0 && fixation2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation2.tStart = t;  // (not accounting for frame time here)
      fixation2.frameNStart = frameN;  // exact frame index
      
      fixation2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fixation2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fixation2.setAutoDraw(false);
    }
    
    // *image_3* updates
    if (t >= 0.0 && image_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_3.tStart = t;  // (not accounting for frame time here)
      image_3.frameNStart = frameN;  // exact frame index
      
      image_3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of imagefix2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function imagefix2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'imagefix2' ---
    for (const thisComponent of imagefix2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function allPrimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'allPrime' ---
    t = 0;
    allPrimeClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // Run 'Begin Routine' code from code_6
    /* Syntax Error: Fix Python code */
    visualPrime_4.setImage(allImage);
    image.setImage(allImage);
    // keep track of which components have finished
    allPrimeComponents = [];
    allPrimeComponents.push(visualPrime_4);
    allPrimeComponents.push(image);
    
    for (const thisComponent of allPrimeComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function allPrimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'allPrime' ---
    // get current time
    t = allPrimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *visualPrime_4* updates
    if (t >= 0.0 && visualPrime_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      visualPrime_4.tStart = t;  // (not accounting for frame time here)
      visualPrime_4.frameNStart = frameN;  // exact frame index
      
      visualPrime_4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (visualPrime_4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      visualPrime_4.setAutoDraw(false);
    }
    
    // *image* updates
    if (t >= 0.0 && image.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image.tStart = t;  // (not accounting for frame time here)
      image.frameNStart = frameN;  // exact frame index
      
      image.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of allPrimeComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function allPrimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'allPrime' ---
    for (const thisComponent of allPrimeComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Run 'End Routine' code from code_6
    /* Syntax Error: Fix Python code */
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function fixationp2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'fixationp2' ---
    t = 0;
    fixationp2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // Run 'Begin Routine' code from ISI_5
    ISI = random() * (1.1 - .5) + .500
    ISI = round(ISI, 1)
    thisExp.addData('ISI', ISI)
    // keep track of which components have finished
    fixationp2Components = [];
    fixationp2Components.push(fix5);
    
    for (const thisComponent of fixationp2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function fixationp2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'fixationp2' ---
    // get current time
    t = fixationp2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fix5* updates
    if (t >= 0 && fix5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fix5.tStart = t;  // (not accounting for frame time here)
      fix5.frameNStart = frameN;  // exact frame index
      
      fix5.setAutoDraw(true);
    }

    frameRemains = 0 + ISI - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fix5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fix5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of fixationp2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function fixationp2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'fixationp2' ---
    for (const thisComponent of fixationp2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "fixationp2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function SIFI2_2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'SIFI2_2' ---
    t = 0;
    SIFI2_2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    circle1_3.setOpacity(opacity);
    circle2_3.setOpacity(opacity2);
    beep1_3 = new sound.Sound({
    win: psychoJS.window,
    value: beepSound,
    secs: -1,
    });
    beep1_3.setVolume(1.0);
    // keep track of which components have finished
    SIFI2_2Components = [];
    SIFI2_2Components.push(fixation_3);
    SIFI2_2Components.push(circle1_3);
    SIFI2_2Components.push(circle2_3);
    SIFI2_2Components.push(beep1_3);
    
    for (const thisComponent of SIFI2_2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function SIFI2_2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'SIFI2_2' ---
    // get current time
    t = SIFI2_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_3* updates
    if (t >= 0.0 && fixation_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_3.tStart = t;  // (not accounting for frame time here)
      fixation_3.frameNStart = frameN;  // exact frame index
      
      fixation_3.setAutoDraw(true);
    }

    if (fixation_3.status === PsychoJS.Status.STARTED && Boolean(((circle2_3.status == FINISHED) && (beep1_3.status == FINISHED)))) {
      fixation_3.setAutoDraw(false);
    }
    
    // *circle1_3* updates
    if (t >= flashOnset && circle1_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle1_3.tStart = t;  // (not accounting for frame time here)
      circle1_3.frameNStart = frameN;  // exact frame index
      
      circle1_3.setAutoDraw(true);
    }

    if (circle1_3.status === PsychoJS.Status.STARTED && frameN >= (circle1_3.frameNStart + 0.0016)) {
      circle1_3.setAutoDraw(false);
    }
    
    // *circle2_3* updates
    if (t >= (flashOnset + SOA) && circle2_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle2_3.tStart = t;  // (not accounting for frame time here)
      circle2_3.frameNStart = frameN;  // exact frame index
      
      circle2_3.setAutoDraw(true);
    }

    if (circle2_3.status === PsychoJS.Status.STARTED && frameN >= (circle2_3.frameNStart + 0.0016)) {
      circle2_3.setAutoDraw(false);
    }
    // start/stop beep1_3
    if (t >= beepOnset && beep1_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      beep1_3.tStart = t;  // (not accounting for frame time here)
      beep1_3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ beep1_3.play(); });  // screen flip
      beep1_3.status = PsychoJS.Status.STARTED;
    }
    if (t >= (beep1_3.getDuration() + beep1_3.tStart)     && beep1_3.status === PsychoJS.Status.STARTED) {
      beep1_3.stop();  // stop the sound (if longer than duration)
      beep1_3.status = PsychoJS.Status.FINISHED;
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of SIFI2_2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function SIFI2_2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'SIFI2_2' ---
    for (const thisComponent of SIFI2_2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    beep1_3.stop();  // ensure sound has stopped at end of routine
    // Run 'End Routine' code from saveData3
    psychoJS.experiment.addData("trial", trial);
    psychoJS.experiment.addData("SOA", SOA);
    
    // the Routine "SIFI2_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function SIFIRespRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'SIFIResp' ---
    t = 0;
    SIFIRespClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_5.keys = undefined;
    key_resp_5.rt = undefined;
    _key_resp_5_allKeys = [];
    // keep track of which components have finished
    SIFIRespComponents = [];
    SIFIRespComponents.push(key_resp_5);
    SIFIRespComponents.push(Options);
    SIFIRespComponents.push(Fixa_44);
    
    for (const thisComponent of SIFIRespComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function SIFIRespRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'SIFIResp' ---
    // get current time
    t = SIFIRespClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *key_resp_5* updates
    if (t >= 0 && key_resp_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_5.tStart = t;  // (not accounting for frame time here)
      key_resp_5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_5.clearEvents(); });
    }

    if (key_resp_5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_5.getKeys({keyList: ['1', '2'], waitRelease: false});
      _key_resp_5_allKeys = _key_resp_5_allKeys.concat(theseKeys);
      if (_key_resp_5_allKeys.length > 0) {
        key_resp_5.keys = _key_resp_5_allKeys[0].name;  // just the first key pressed
        key_resp_5.rt = _key_resp_5_allKeys[0].rt;
        // was this correct?
        if (key_resp_5.keys == corrAns) {
            key_resp_5.corr = 1;
        } else {
            key_resp_5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *Options* updates
    if (t >= 0.0 && Options.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      Options.tStart = t;  // (not accounting for frame time here)
      Options.frameNStart = frameN;  // exact frame index
      
      Options.setAutoDraw(true);
    }

    
    // *Fixa_44* updates
    if (t >= 0.0 && Fixa_44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      Fixa_44.tStart = t;  // (not accounting for frame time here)
      Fixa_44.frameNStart = frameN;  // exact frame index
      
      Fixa_44.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (Fixa_44.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      Fixa_44.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of SIFIRespComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function SIFIRespRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'SIFIResp' ---
    for (const thisComponent of SIFIRespComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // was no response the correct answer?!
    if (key_resp_5.keys === undefined) {
      if (['None','none',undefined].includes(corrAns)) {
         key_resp_5.corr = 1;  // correct non-response
      } else {
         key_resp_5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_5.corr, level);
    }
    psychoJS.experiment.addData('key_resp_5.keys', key_resp_5.keys);
    psychoJS.experiment.addData('key_resp_5.corr', key_resp_5.corr);
    if (typeof key_resp_5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_5.rt', key_resp_5.rt);
        routineTimer.reset();
        }
    
    key_resp_5.stop();
    // the Routine "SIFIResp" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function blank500_5RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'blank500_5' ---
    t = 0;
    blank500_5Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // Run 'Begin Routine' code from code_7
    jitter = ((Math.random() * (2.0 - 1)) + 1);
    jitter = Math.round(jitter, 1);
    psychoJS.experiment.addData("jitter", jitter);
    
    // keep track of which components have finished
    blank500_5Components = [];
    blank500_5Components.push(blank1_5);
    
    for (const thisComponent of blank500_5Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function blank500_5RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'blank500_5' ---
    // get current time
    t = blank500_5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *blank1_5* updates
    if (t >= 0.0 && blank1_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      blank1_5.tStart = t;  // (not accounting for frame time here)
      blank1_5.frameNStart = frameN;  // exact frame index
      
      blank1_5.setAutoDraw(true);
    }

    frameRemains = 0.0 + jitter - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (blank1_5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      blank1_5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of blank500_5Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function blank500_5RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'blank500_5' ---
    for (const thisComponent of blank500_5Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // the Routine "blank500_5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function instrucRateRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'instrucRate' ---
    t = 0;
    instrucRateClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    // setup some python lists for storing info about the mouse_2
    mouse_2.clicked_name = [];
    gotValidClick = false; // until a click is received
    // keep track of which components have finished
    instrucRateComponents = [];
    instrucRateComponents.push(text_13);
    instrucRateComponents.push(whiteSquare);
    instrucRateComponents.push(mouse_2);
    
    for (const thisComponent of instrucRateComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function instrucRateRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'instrucRate' ---
    // get current time
    t = instrucRateClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_13* updates
    if (t >= 0.0 && text_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_13.tStart = t;  // (not accounting for frame time here)
      text_13.frameNStart = frameN;  // exact frame index
      
      text_13.setAutoDraw(true);
    }

    
    // *whiteSquare* updates
    if (t >= 0.0 && whiteSquare.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      whiteSquare.tStart = t;  // (not accounting for frame time here)
      whiteSquare.frameNStart = frameN;  // exact frame index
      
      whiteSquare.setAutoDraw(true);
    }

    // *mouse_2* updates
    if (t >= 0.0 && mouse_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      mouse_2.tStart = t;  // (not accounting for frame time here)
      mouse_2.frameNStart = frameN;  // exact frame index
      
      mouse_2.status = PsychoJS.Status.STARTED;
      mouse_2.mouseClock.reset();
      prevButtonState = mouse_2.getPressed();  // if button is down already this ISN'T a new click
      }
    if (mouse_2.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = mouse_2.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [whiteSquare]) {
            if (obj.contains(mouse_2)) {
              gotValidClick = true;
              mouse_2.clicked_name.push(obj.name)
            }
          }
          if (gotValidClick === true) { // abort routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of instrucRateComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function instrucRateRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'instrucRate' ---
    for (const thisComponent of instrucRateComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // store data for psychoJS.experiment (ExperimentHandler)
    // the Routine "instrucRate" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function fix6RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'fix6' ---
    t = 0;
    fix6Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    fix6Components = [];
    fix6Components.push(fixation3);
    
    for (const thisComponent of fix6Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function fix6RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'fix6' ---
    // get current time
    t = fix6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation3* updates
    if (t >= 0.0 && fixation3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation3.tStart = t;  // (not accounting for frame time here)
      fixation3.frameNStart = frameN;  // exact frame index
      
      fixation3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (fixation3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      fixation3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of fix6Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function fix6RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'fix6' ---
    for (const thisComponent of fix6Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function ratingTaskRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'ratingTask' ---
    t = 0;
    ratingTaskClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    emotionImage.setImage(image);
    // Run 'Begin Routine' code from saveData6
    background = new visual.ShapeStim({"win": psychoJS.window, "vertices": 4, "size": [4, 4], "lineWidth": 1.0, "colorSpace": "rgb", "lineColor": "white", "fillColor": "white", "opacity": null, "interpolate": true});
    background.setAutoDraw(true);
    keyText.alignText = "left";
    
    arousalRating.reset()
    valenceRating.reset()
    // setup some python lists for storing info about the mouse
    mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    // keep track of which components have finished
    ratingTaskComponents = [];
    ratingTaskComponents.push(emotionImage);
    ratingTaskComponents.push(arousalRating);
    ratingTaskComponents.push(arousalScale);
    ratingTaskComponents.push(valenceRating);
    ratingTaskComponents.push(valenceScale);
    ratingTaskComponents.push(keyText);
    ratingTaskComponents.push(blueSquare);
    ratingTaskComponents.push(mouse);
    ratingTaskComponents.push(Next);
    
    for (const thisComponent of ratingTaskComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function ratingTaskRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'ratingTask' ---
    // get current time
    t = ratingTaskClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *emotionImage* updates
    if (t >= 0.0 && emotionImage.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      emotionImage.tStart = t;  // (not accounting for frame time here)
      emotionImage.frameNStart = frameN;  // exact frame index
      
      emotionImage.setAutoDraw(true);
    }

    
    // *arousalRating* updates
    if (t >= 0.0 && arousalRating.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      arousalRating.tStart = t;  // (not accounting for frame time here)
      arousalRating.frameNStart = frameN;  // exact frame index
      
      arousalRating.setAutoDraw(true);
    }

    
    // *arousalScale* updates
    if (t >= 0.0 && arousalScale.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      arousalScale.tStart = t;  // (not accounting for frame time here)
      arousalScale.frameNStart = frameN;  // exact frame index
      
      arousalScale.setAutoDraw(true);
    }

    
    // *valenceRating* updates
    if (t >= 0.0 && valenceRating.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      valenceRating.tStart = t;  // (not accounting for frame time here)
      valenceRating.frameNStart = frameN;  // exact frame index
      
      valenceRating.setAutoDraw(true);
    }

    
    // *valenceScale* updates
    if (t >= 0.0 && valenceScale.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      valenceScale.tStart = t;  // (not accounting for frame time here)
      valenceScale.frameNStart = frameN;  // exact frame index
      
      valenceScale.setAutoDraw(true);
    }

    
    // *keyText* updates
    if (t >= 0.0 && keyText.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      keyText.tStart = t;  // (not accounting for frame time here)
      keyText.frameNStart = frameN;  // exact frame index
      
      keyText.setAutoDraw(true);
    }

    
    // *blueSquare* updates
    if (t >= 0.0 && blueSquare.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      blueSquare.tStart = t;  // (not accounting for frame time here)
      blueSquare.frameNStart = frameN;  // exact frame index
      
      blueSquare.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (blueSquare.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      blueSquare.setAutoDraw(false);
    }
    // *mouse* updates
    if (t >= 0.0 && mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      mouse.tStart = t;  // (not accounting for frame time here)
      mouse.frameNStart = frameN;  // exact frame index
      
      mouse.status = PsychoJS.Status.STARTED;
      mouse.mouseClock.reset();
      prevButtonState = mouse.getPressed();  // if button is down already this ISN'T a new click
      }
    if (mouse.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [Next]) {
            if (obj.contains(mouse)) {
              gotValidClick = true;
              mouse.clicked_name.push(obj.name)
            }
          }
          if (gotValidClick === true) { // abort routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *Next* updates
    if (t >= 0.0 && Next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      Next.tStart = t;  // (not accounting for frame time here)
      Next.frameNStart = frameN;  // exact frame index
      
      Next.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of ratingTaskComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function ratingTaskRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'ratingTask' ---
    for (const thisComponent of ratingTaskComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Run 'End Routine' code from saveData6
    psychoJS.experiment.addData("emotion_image", image);
    psychoJS.experiment.addData("emotion", emotion);
    background = new visual.ShapeStim({"win": psychoJS.window, "vertices": 4, "size": [4, 4], "lineWidth": 1.0, "colorSpace": "rgb", "lineColor": "black", "fillColor": "black", "opacity": null, "interpolate": true});
    background.setAutoDraw(true);
    
    psychoJS.experiment.addData('arousalRating.response', arousalRating.getRating());
    psychoJS.experiment.addData('arousalRating.rt', arousalRating.getRT());
    psychoJS.experiment.addData('valenceRating.response', valenceRating.getRating());
    psychoJS.experiment.addData('valenceRating.rt', valenceRating.getRT());
    // store data for psychoJS.experiment (ExperimentHandler)
    // the Routine "ratingTask" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function instrucRate_2RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'instrucRate_2' ---
    t = 0;
    instrucRate_2Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    key_resp_18.keys = undefined;
    key_resp_18.rt = undefined;
    _key_resp_18_allKeys = [];
    // keep track of which components have finished
    instrucRate_2Components = [];
    instrucRate_2Components.push(text_14);
    instrucRate_2Components.push(key_resp_18);
    
    for (const thisComponent of instrucRate_2Components)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function instrucRate_2RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'instrucRate_2' ---
    // get current time
    t = instrucRate_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_14* updates
    if (t >= 0.0 && text_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_14.tStart = t;  // (not accounting for frame time here)
      text_14.frameNStart = frameN;  // exact frame index
      
      text_14.setAutoDraw(true);
    }

    
    // *key_resp_18* updates
    if (t >= 0.0 && key_resp_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_18.tStart = t;  // (not accounting for frame time here)
      key_resp_18.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_18.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_18.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_18.clearEvents(); });
    }

    if (key_resp_18.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_18.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_18_allKeys = _key_resp_18_allKeys.concat(theseKeys);
      if (_key_resp_18_allKeys.length > 0) {
        key_resp_18.keys = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].name;  // just the last key pressed
        key_resp_18.rt = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of instrucRate_2Components)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function instrucRate_2RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'instrucRate_2' ---
    for (const thisComponent of instrucRate_2Components) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_18.corr, level);
    }
    psychoJS.experiment.addData('key_resp_18.keys', key_resp_18.keys);
    if (typeof key_resp_18.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_18.rt', key_resp_18.rt);
        routineTimer.reset();
        }
    
    key_resp_18.stop();
    // the Routine "instrucRate_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function QuesRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'Ques' ---
    t = 0;
    QuesClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // update component parameters for each repeat
    //skip this component online
    continueRoutine = false;
    // keep track of which components have finished
    QuesComponents = [];
    QuesComponents.push(form_2);
    QuesComponents.push(button);
    
    for (const thisComponent of QuesComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function QuesRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'Ques' ---
    // get current time
    t = QuesClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *form_2* updates
    if (t >= 0.0 && form_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      form_2.tStart = t;  // (not accounting for frame time here)
      form_2.frameNStart = frameN;  // exact frame index
      
      form_2.setAutoDraw(true);
    }

    
    // *button* updates
    if (t >= 0 && button.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      button.tStart = t;  // (not accounting for frame time here)
      button.frameNStart = frameN;  // exact frame index
      
      button.setAutoDraw(true);
    }

    if (button.status === PsychoJS.Status.STARTED) {
      // check whether button has been pressed
      if (button.isClicked) {
        if (!button.wasClicked) {
          // store time of first click
          button.timesOn.push(button.clock.getTime());
          button.numClicks += 1;
          // store time clicked until
          button.timesOff.push(button.clock.getTime());
        } else {
          // update time clicked until;
          button.timesOff[button.timesOff.length - 1] = button.clock.getTime();
        }
        if (!button.wasClicked) {
          // end routine when button is clicked
          continueRoutine = false;
        }
        // if button is still clicked next frame, it is not a new click
        button.wasClicked = true;
      } else {
        // if button is clicked next frame, it is a new click
        button.wasClicked = false;
      }
    } else {
      // keep clock at 0 if button hasn't started / has finished
      button.clock.reset();
      // if button is clicked next frame, it is a new click
      button.wasClicked = false;
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of QuesComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function QuesRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'Ques' ---
    for (const thisComponent of QuesComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    form_2.addDataToExp(psychoJS.experiment, 'rows');
    psychoJS.experiment.addData('button.numClicks', button.numClicks);
    psychoJS.experiment.addData('button.timesOn', button.timesOn);
    psychoJS.experiment.addData('button.timesOff', button.timesOff);
    // the Routine "Ques" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function endTextRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'endText' ---
    t = 0;
    endTextClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    // keep track of which components have finished
    endTextComponents = [];
    endTextComponents.push(text_12);
    
    for (const thisComponent of endTextComponents)
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
    return Scheduler.Event.NEXT;
  }
}

function endTextRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'endText' ---
    // get current time
    t = endTextClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_12* updates
    if (t >= 0.0 && text_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_12.tStart = t;  // (not accounting for frame time here)
      text_12.frameNStart = frameN;  // exact frame index
      
      text_12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    for (const thisComponent of endTextComponents)
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
        break;
      }
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}

function endTextRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'endText' ---
    for (const thisComponent of endTextComponents) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}

function importConditions(currentLoop) {
  return async function () {
    psychoJS.importAttributes(currentLoop.getCurrentTrial());
    return Scheduler.Event.NEXT;
    };
}

async function quitPsychoJS(message, isCompleted) {
  // Check for and save orphaned data
  if (psychoJS.experiment.isEntryEmpty()) {
    psychoJS.experiment.nextEntry();
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  psychoJS.window.close();
  psychoJS.quit({message: message, isCompleted: isCompleted});
  
  return Scheduler.Event.QUIT;
}
